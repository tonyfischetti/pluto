<h1 id="pluto-documentation">Pluto documentation</h1>
<hr />
<h3 id="get-size">GET-SIZE</h3>
<pre>
Uses `du` to return just the size of the provided file.
   `just-bytes` ensures that the size is only counted in bytes (returns integer) [default nil]
</pre>
<p><br></p>
<pre><code>(GET-SIZE &quot;interior-of-a-heart.txt&quot;)</code></pre>
<p>Returns:</p>
<pre><code>17k</code></pre>
<hr size="1">
<pre><code>(GET-SIZE &quot;interior-of-a-heart.txt&quot; :JUST-BYTES T)</code></pre>
<p>Returns:</p>
<pre><code>14433</code></pre>
<hr />
<h3 id="section">-&lt;&gt;</h3>
<pre>
Threading macro (put <> where the argument should be)
   Stolen from https://github.com/sjl/cl-losh/blob/master/src/control-flow.lisp
</pre>
<p><br></p>
<pre><code>(-&lt;&gt; &quot;4&quot; (PARSE-INTEGER &lt;&gt;) (SQRT &lt;&gt;))</code></pre>
<p>Returns:</p>
<pre><code>2.0</code></pre>
<hr />
<h3 id="for-each">FOR-EACH</h3>
<pre>
A super-duper imperative looping construct.
   It takes either
     a filename string    (to be treated as a file and goes line by line)
     a hash-table
     a vector
     a list
     a string             (that goes character by character)
     or a stream          (that goes line by line)
  It is anaphoric and introduces
     `index!`             (which is a zero indexed counter of which element we are on)
     `key!`               (the key of the current hash-table entry [only for hash-tables and alists])
     `value!`             (the value of the current element)
     `this-pass!`         (a block that returning from immediately moves to the next iteration)
     `this-loop!`         (a block that returning from exits the loop)
  For convenience, `(continue!)` and `(break!)` will execute `(return-from this-pass!)`
  and `(return-from this-loop!)`, respectively
  If it's a filename, the external format is *pluto-external-format* (:UTF-8 by default)
  Oh, it'll die gracefully if Control-C is used during the loops execution.
  And, finally, for extra performance, you can call it's subordinate functions directly.
  They are... for-each/line, for-each/list, for-each/hash, for-each/vector,
  for-each/stream, and for-each/alist
</pre>
<p><br></p>
<p>for-each/list</p>
<pre><code>(FOR-EACH/LIST &#39;(A B C D E)
  (IF (&gt; INDEX! 2)
      (BREAK!))
  (FORMAT T &quot;~A~%&quot; VALUE!))</code></pre>
<p>Output:</p>
<pre><code>A
B
</code></pre>
<hr size="1">
<p>for-each/list</p>
<pre><code>(FOR-EACH &#39;(A B C D E)
  (IF (= INDEX! 3)
      (CONTINUE!))
  (FORMAT T &quot;~A~%&quot; VALUE!))</code></pre>
<p>Output:</p>
<pre><code>A
B
D
E
</code></pre>
<hr size="1">
<p>for-each/line</p>
<pre><code>(FOR-EACH &quot;somebody.txt&quot;
  (FORMAT T &quot;~A -&gt; ~A~%&quot; INDEX! VALUE!))</code></pre>
<p>Output:</p>
<pre><code>1 -&gt; we gotta celebrate diversity
2 -&gt; in the university
</code></pre>
<hr size="1">
<p>for-each/hash</p>
<pre><code>(LET ((TMP (MAKE-HASH-TABLE)))
  (SETF (GETHASH &#39;GREEN TMP) &quot;veridian&quot;)
  (SETF (GETHASH &#39;RED TMP) &quot;cadmium&quot;)
  (FOR-EACH TMP
    (FORMAT T &quot;~A -&gt; ~A~%&quot; KEY! VALUE!)))</code></pre>
<p>Output:</p>
<pre><code>GREEN -&gt; veridian
RED -&gt; cadmium
</code></pre>
